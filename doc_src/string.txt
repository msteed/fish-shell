\section string string - manipulate strings

\subsection string-synopsis Synopsis
\fish{synopsis}
string length [(-q | --quiet)] [--] [STRING...]
string sub [(-s | --start)] [(-l | --length)] [(-q | --quiet)] [STRING...]
string split [(-m | --max) MAX] [(-r | --right)] [(-q | --quiet)] [--]
             SEP [STRING...]
string join [(-q | --quiet)] [--] SEP [STRING...]
string trim [(-l | --left)] [(-r | --right)] [(-c | --chars CHARS)]
            [(-q | --quiet)] [--] [STRING...]
string escape [(-n | --no-quoted)] [--] [STRING...]
string match [(-m | --max) MAX] [(-i | --ignore-case)] [(-r | --regex)]
             [(-n | --index)] [(-q | --quiet)] [--] PATTERN [STRING...]
string replace [(-m | --max) MAX] [(-i | --ignore-case)] [(-r | --regex)]
               [(-q | --quiet)] [--] PATTERN REPLACEMENT [STRING...]
\endfish


\subsection string-description Description

`string` performs operations on strings.

STRING arguments are taken from the command line unless standard input is connected to a pipe or a file, in which case they are read from standard input. It is an error to supply STRING arguments on the command line and on standard input.

Arguments beginning with `-` are normally interpreted as switches; `--` causes the following arguments not to be treated as switches even if they begin with `-`. Switches and required arguments are recognized only on the command line.

Most subcommands accept a `-q` or `--quiet` switch, which suppresses the usual output but exits with the documented status.

TBD: Currently, multiple outputs are separated by newlines. Should IFS be used instead?

TBD: Magic behavior when used in command substitution: no IFS splitting.

The following subcommands are available:

- `length` reports the length of each string argument in characters. Exit status: 0 if at least one non-empty STRING was given, or 1 otherwise.

- `sub` prints a substring of each string argument. The start of the substring can be specified with `-s` or `--start` followed by a 1-based index value. Positive index values are relative to the start of the string and negative index values are relative to the end of the string. The default start value is 1. The length of the substring can be specified with `-l` or `--length`. If the length is not specified, the substring continues to the end of each STRING. Exit status: 0 if at least one substring operation was performed, 1 otherwise.

- `split` splits each STRING on the separator SEP. If `-m` or `--max` is specified, at most MAX splits are done. If `-r` or `--right` is given, splitting is performed right-to-left. This is useful in combination with `-m` or `--max`. Exit status: 0 if at least one split was performed, or 1 otherwise.

- `join` joins its STRING arguments into a single string separated by SEP, which can be an empty string. Exit status: 0 if at least one join was performed, or 1 otherwise.

- `trim` removes leading and trailing whitespace from each STRING. If `-l` or `--left` is given, only leading whitespace is removed. If `-r` or `--right` is given, only trailing whitespace is trimmed. The `-c` or `--chars` switch causes the characters in CHARS to be removed instead of whitespace. Exit status: 0 if at least one character was trimmed, or 1 otherwise.

- `escape` escapes each STRING such that it can be passed back to `eval` to produce the original argument again. By default, all special characters are escaped, and quotes are used to simplify the output when possible. If `-q` or `--no-quote` is given, the simplifying quoted format is not used. If `-t` or `--no-tilde` is given, the tilde character (~) is not escaped. Exit status: 0 if at least one string was escaped, or 1 otherwise.

- `match` tests each STRING against a pattern and prints matching substrings. All matches are printed unless `-m` or `--max` is given, in which cases at most MAX matches are reported. Matching can be made case-insensitive with `-i` or `--ignore-case`. If `-n` or `--index` is given, the 1-based index of the start of each match is reported instead of the matching substring, or 0 for no match. By default, PATTERN is interpreted as a glob pattern matched against each entire string argument. If `-r` or `--regex` is given, the pattern is interpreted as a regular expression. Exit status: 0 if at least one match was found, or 1 otherwise.

- `replace` is similar to `match` but replaces matching non-overlapping substrings with a replacement string and prints the result. Unless `-r` or `--regex` is specified, PATTERN is treated as a literal substring to be matched. Exit status: 0 if at least one replacement was performed, or 1 otherwise.


\subsection string-example Examples

\fish
string length 'hello, world'
# Output:
# 12

string length -q $str
# Equivalent to test -n $str
\endfish

\fish
string sub --length 2 abcde
# Output:
# ab

string sub -s 2 -l 2 abcde
# Output:
# bc

string sub --start -2 abcde
# Output:
# de
\endfish

\fish
string split . example.com
# Output:
# example
# com

string split -r -n1 / /usr/local/bin/fish
# Output:
# /usr/local/bin
# fish
\endfish

\fish
seq 3 | string join ...
# Output:
# 1...2...3
\endfish

\fish
string trim \tabc\ d\n
# Output:
# abc d

string trim -r -c yz xyzzy zany
# Output:
# x
# zan
\endfish

\fish
echo \a | string escape
# Output:
# \cg
\endfish

\fish
# glob examples

string match '?' a
# Output:
# a

string match 'a*b' axxb
# Output:
# axxb

string match -i 'a??B' Axxb
# Output:
# Axxb

string match -a -i '[aeiou]' A B C D E
# Output:
# A
# E

string match '[^fb]*' foo bar baz qux
# Output:
# qux

echo 'ok?' | string match '*\?'
# Output:
# ok?
\endfish

\fish
string replace ...
\endfish
